use std::env;
use std::fs;
use std::path::PathBuf;
use structopt::clap::Shell;
use structopt::StructOpt;

#[path = "src/cli.rs"]
mod cli;

fn apply_template(template: &PathBuf) -> String {
    let outdir =
        PathBuf::from(env::var_os("OUT_DIR").expect("OUT_DIR environment variable not defined"));
    fs::create_dir_all(&outdir).expect("unable to create out dir");

    let profile = env::var_os("PROFILE").expect("PROFILE environment variable not defined");
    let mdevctl_bin_path = PathBuf::from("target").join(profile).join("mdevctl");

    fs::read_to_string(template)
        .expect(format!("Failed to read template {:?}", template).as_str())
        .replace("@@mdevctl@@", mdevctl_bin_path.to_str().unwrap())
        .replace(
            "@@mdevctl.bash@@",
            outdir.join("mdevctl.bash").to_str().unwrap(),
        )
        .replace(
            "@@lsmdev.bash@@",
            outdir.join("lsmdev.bash").to_str().unwrap(),
        )
        .replace(
            "@@generated_notice@@",
            format!(
                "# DO NOT EDIT\n# This file is automatically generated from {:?}",
                template
            )
            .as_str(),
        )
}

fn main() {
    let outdir =
        PathBuf::from(env::var_os("OUT_DIR").expect("OUT_DIR environment variable not defined"));

    // generate bash completions for both executables
    cli::MdevctlCommands::clap().gen_completions("mdevctl", Shell::Bash, &outdir);
    cli::LsmdevOptions::clap().gen_completions("lsmdev", Shell::Bash, &outdir);

    // Generate a makefile for installing the auxiliary files based on the Makefile.in template
    let makefile_in = PathBuf::from("Makefile.in");
    let makefile_out = PathBuf::from(makefile_in.file_stem().unwrap());
    let contents = apply_template(&makefile_in);

    // FIXME: build.rs really shouldn't touch anything outside of OUT_DIR, but generating the
    // Makefile in a directory named ./target/$PROFILE/build/mdevctl-$HASH/out/ is very
    // undiscoverable and kind of defeats the purpose. Need to find a better solution.
    std::fs::write(&makefile_out, contents)
        .expect(format!("Failed to write {:?}", makefile_out).as_str());
    println!("cargo:rerun-if-changed={}", makefile_in.to_str().unwrap());
}
